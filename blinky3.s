; this is one assembly implementation of the infamous blinky example;
; target microcontroler: LPC1768 available on board Keil MCB1700 (or Embest EM-LPC1700 board)
; I tested it first on EM-LPC1700 board as it's cheaper!
;
; Note1: it has lots of comments, as it is intended for the one who
; sees for the first time assembly;
; Note2: some parts of the implementation are written in a more complicated manner
; than necessary for the purpose of illustrating for example different memory 
; addressing methods;
; Note3: each project will have to have added to it also system_LPC17xx.s (added
; automatically by Keil uVision when you create your project) and system_LPC17xx.c
; which you can copy from your install directory of Keil IDE (for example,
; C:\Keil\ARM\Startup\NXP\LPC17xx\system_LPC17xx.c)
; Note4: system_LPC17xx.s basically should contain the following elements:
; -- defines the size of the stack
; -- defines the size of the heap
; -- defines the reset vector and all interrupt vectors
; -- the reset handler that jumps to your code
; -- default interrupt service routines that do nothing
; -- defines some functions for enabling and disabling interrupts
	
	; Directives
	; they assist and control the assembly process; directives or "pseudo-ops"
	; are not part of the instruction set; they change the way the code is assembled;
	
	; THUMB directive placed at the top of the file to specify that
	; code is generated with Thumb instructions;
	THUMB
	; some directives define where and how the objects (code and variables) are
	; placed in memory; here is a list with some examples:
	; AREA, in assembly code, the smallest locatable unit is an AREA
	; CODE is the place for machine instructions (typically flash ROM)
	; DATA is the place for global variables (typically RAM)
	; STACK is the place for the stack (also in RAM)
	; ALIGN=n modifier starts the area aligned to 2^n bytes
	; |.text| is used to connect this program with the C code generated by
	; the compiler, which we need if linking assembly code to C code;
	; it is also needed for code sections associated with the C library;
	; NONINT defines a RAM area that is not initialized (normally RAM areas are
	; initialized to zero); Note: ROM begins at 0x00000000 and RAM begins at 
	; 0x2000000;
	; EXPORT is a directive in a file where we define an object and 
	; IMPORT directive is used in a file from where we wish to access the object;
	; Note: we can export a function in an assembly file and call the function
	; from a C file; also, we can define a function in C file, and IMPORT the function
	; into an assembly file;
	; GLOBAL is a synonym for EXPORT
	; ALIGN directive is used to ensure the next object is aligned properly; for example,
	; machine instructions must be half-word aligned, 32-bit data accessed with LDR, STR
	; must be word-aligned; good programmers place an ALIGN at the end of each file so the
	; start of every file is automatically aligned;
	; END directive is placed at the end of each file
	; EQU directive gives a symbolic name to a numeric constant, a register-relative 
	; value or a program-relative value; we'll use EQU to define I/O port addresses;
	AREA	|.text|, CODE, READONLY ; following lines are to be placed in code space
	EXPORT 	__main 
	ENTRY

	; EQUates to make the code more readable; to turn LED P2.0 on and off 
	; we will write the bit 0 of the registers FIO2SET (to set HIGH) and FIO2CLR (to set LOW); 
	; refer to page 122 of the LPC17xx user manual to see the adresses of these registers; they are:
FIO2SET	 EQU 0x2009C058
FIO2CLR	 EQU 0x2009C05C
	; we will implement a dirty delay by decrementing a large enough
	; number of times a register;
LEDDELAY EQU 10000000

__main
	; (1) we want to set as output the direction of the pins that 
	; drive the 8 LEDs; these pins belong to the Port 2 
    ; and are: P2.0, P2.1, P2.2,...,P2.7 
	; to set them as output, we must set to 1 the corresponding bits in
	; registers (page 122 of LPC17xx user manual):
	; FIO2DIR - 0x2009C040 
    ; that is, we'll set to 1 bits 0,1,2,…7 of the register at address 0x2009C040, 
	; which means writing 0x000000FF to 
    ; this location; 

	MOV R1, #0x0 ; init R1 register to 0 to "build" address
	MOVT R1, #0x2009 ; assign 0x20090000 to R1; MOVT assigns to upper nibble
	MOV R3, #0xC000 ; move 0xC000 into R3
	ADD R1, R1, R3 ; add 0xC000 to R1 to get 0x2009C000
	MOV R4, #0x000000FF ; place 0x000000FF (i.e., bits 0,1,2,…7) into R4 
    ; now, place contents of R4 (i.e. 0x000000FF) to address 
    ; 0x2009C040 (i.e., register FIO2DIR); this sets pins 
    ; 0,1,2,3,..7 as output direction; 
    ; Note: address is created by adding the offset 0x40 to R1  
    ; Note: the entire complication above could be replaced with 
    ; simply loading R1 with =FIO2DIR (but we wanted to experiment with 
    ; different flavors of MOV, to upper and lower nibbles); we'll use 
    ; the simpler version later; 
	STR R4, [R1, #0x40] ; set output direction for pins of Port 2 by writing to register FIO2DIR 
    ; (2) set HIGH the LED driven by P2.0; to do that we load current 
    ; contents of register FIO2SET (i.e., memory address 0x2009C058) to R3, 
    ; set to 1 its 0th bit, and then put it back into the location at 
    ; memory address 0x2009C058 (i.e., effectively writing into register FIO2SET); 
    LDR R1, =FIO2SET ; we'll not touch R1 anymore so that it keeps this address 
    LDR R3, [R1] 
    ORR R3, #0x00000001 ; set to logic 1 bit 0 of R3 
    STR R3, [R1] 
	; (3) some initializations 
	LDR R0, =LEDDELAY ; initialize R0 for countdown
	;LDR R2, =FIO1CLR ; we'll not touch R2 anymore so that it keeps this address
     LDR R2, =FIO2CLR ;
	 ; now, the main thing: turn the LED P2.0 on and off repeatedly; 
     ; this is done by setting the bit 0 of registers FIO2CLR and FIO2SET; 
	; Note: one could do this in a simpler way by using a toggling trick:
	; toggle (could be done using exclusive or with 1) bit 0 of register 
	; FIO2PIN instead (page 122 of LPC17xx user manual) and not use 
	; FIO2CLR and FIO2SET; I do not recommend however this trick as
	; due to the peculiarities of FIO2PIN;
loop
MOV R4, #1
led_on
	SUBS R0, #1 ; decrement R0; this sets N,Z,V,C status bits
	BGT led_on ; if zero not reached yet, go back and keep decrementing
	LDR R3, [R2] ; recall that R2 stores =FIO2CLR	
	ORR R3, R4 ; set to logic 1 bit 0 of R3
	STR R3, [R2] ; place R3 contents into FIO2CLR, which will put pin on LOW
	LDR R0, =LEDDELAY ; initialize R0 for countdown
led_off
	SUBS R0, #1 ; decrement R0; this sets N,Z,V,C status bits
	BGT led_off ; if zero not reached yet, go back and keep decrementing
	LDR R3, [R1] ; recall that R1 stores =FIO1SET	
	ORR R3, R4 ; set to logic 1 bit 0 of R3
	STR R3, [R1] ; place R3 contents into FIO2SET, which will put pin on HIGH
	LDR R0, =LEDDELAY ; initialize R0 for countdown
	; now do it again;
	B loop 

	ALIGN
	END